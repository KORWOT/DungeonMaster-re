# **던전 마스터: 통합 단계별 실무 개발 플랜 v2.3 (Full Text)**

## **I. 개요 및 핵심 원칙**

본 문서는 '던전 마스터' 프로젝트의 성공적인 개발을 위한 구체적인 실행 계획을 정의합니다. 모든 개발 단계는 아래의 핵심 아키텍처 원칙을 기반으로 진행됩니다.

* **데이터 주도 설계 (Data-Driven Design):** 모든 게임 데이터(유닛, 스킬, 장비 등)는 **ScriptableObject(SO)** 를 '청사진(Blueprint)'으로 사용하여 관리합니다. 런타임 인스턴스는 이 청사진을 복사하여 사용하며, 원본 SO는 절대 수정하지 않습니다.  
* **이벤트 기반 아키텍처 (Event-Driven Architecture):** 시스템 간의 모든 통신은 \*\*SO 기반 이벤트 채널(Event Channel)\*\*을 통해 이루어집니다. 이를 통해 시스템 간의 결합도를 최소화(느슨한 결합)하고, 확장성과 유지보수성을 극대화합니다.  
* **SOLID 원칙 및 UnityEngine 종속성 분리:** 모든 코드는 SOLID 원칙을 준수합니다. 특히, 핵심 게임 로직(스탯 계산, 데미지 공식 등)은 순수 C\#으로 작성하여 UnityEngine으로부터의 종속성을 분리하고 테스트 용이성을 확보합니다.  
* **MVVM 패턴 (UI):** 모든 UI는 UI Toolkit을 사용하여 **Model-View-ViewModel** 패턴으로 구현합니다. View(UXML/USS)와 Logic(ViewModel)을 명확히 분리하여 협업 효율과 유지보수성을 높입니다.  
* **문서 준수:** 모든 파일 및 폴더 위치, 네이밍 컨벤션은 '던전 마스터\_ 폴더 구조 및 규칙 가이드 v1.9'를 엄격히 따릅니다.  
* **UI 동적 로딩 정책 (Addressables Hybrid-Model):** UI 리소스는 메모리 효율성과 라이브 서비스 유연성을 위해 하이브리드 정책에 따라 관리합니다.  
* **용어 통일:** 기획서의 '베이스 카드'는 구현 시 UnitData SO를 지칭합니다. 문서에서는 명확성을 위해 '베이스 카드(UnitData)'와 같이 병기할 수 있습니다. 모든 문서와 코드에서 용어의 일관성을 유지합니다.

## **II. 문서 관리 정책**

* **버전 관리:** 본 문서는 Git을 통해 관리되며, 모든 주요 변경 사항은 버전 번호(vX.X)를 갱신하고 변경 이력을 문서 상단에 기록해야 합니다. (v2.3: Phase별 검증/문서화, 데이터 정책, UI/보안/성능 일정 등 실무 프로세스 강화)  
* **변경 절차:** 문서 내용의 변경은 팀 리뷰를 거쳐 승인된 후에만 반영하는 것을 원칙으로 합니다. 이는 계획의 일관성을 유지하고 모든 팀원이 변경 사항을 인지하도록 하기 위함입니다.  
* **동기화:** 본 문서의 내용은 프로젝트 위키(예: Notion, Confluence)에 동기화하여 항상 최신 상태를 유지하고 접근성을 높입니다.

## **III. 전체 시스템 아키텍처 흐름도**

본 프로젝트의 데이터 및 이벤트 흐름은 아래 다이어그램을 따릅니다. (프로젝트 위키에는 이미지/SVG 형태로 변환하여 삽입하는 것을 권장합니다.)

graph TD  
    subgraph "영구 데이터 (Project Assets)"  
        A\[SO Blueprints: UnitData, SkillData etc.\]  
        B\[SO Event Channels: OnUnitKilledEvent etc.\]  
        C\[SO Balance Data: DamageFormula, GrowthRate etc.\]  
    end

    subgraph "런타임 (In-Game Scene)"  
        D\[Managers: UnitManager, CombatManager etc.\]  
        E\[Runtime Instances: InGameUnit, PlayerStats\]  
        F\[UI: ViewModels & ViewControllers\]  
        H\[ServerAPIManager\]  
    end

    subgraph "저장 데이터 & 서버"  
        G\[Save File: PlayerData.json\]  
        I\[Game Server (간이/정식)\]  
    end

    A \-- 1\. 청사진으로 사용 \--\> D  
    D \-- 2\. 데이터 복사하여 생성 \--\> E  
    E \-- 3\. 상태 변경 \--\> E  
    D \-- 4\. 이벤트 발행 \--\> B  
    B \-- 5\. 이벤트 수신 \--\> D  
    B \-- 6\. 이벤트 수신 \--\> F  
    F \-- 7\. 유저 입력/요청 이벤트 발행 \--\> B  
    F \-- 8\. ViewModel 데이터 바인딩 \--\> F  
    G \-- 9\. Load \--\> D  
    D \-- 10\. Save \--\> G  
    C \-- 11\. 밸런스 값 참조 \--\> D  
    D \-- 12\. 서버 요청 \--\> H  
    H \-- 13\. API Call \--\> I  
    I \-- 14\. 검증 및 결과 반환 \--\> H

**흐름 설명:**

1. **초기화:** Manager들은 SO Blueprint를 참조하여 게임 객체를 설정합니다.  
2. **인스턴스화:** Manager는 SO Blueprint의 데이터를 복사하여 Runtime Instance를 생성합니다. (예: UnitManager가 UnitData를 기반으로 InGameUnit 생성)  
3. **상태 변화:** 게임 플레이 중 발생하는 모든 변화(체력 감소 등)는 Runtime Instance에만 적용됩니다.  
4. **이벤트 발행:** 특정 상황 발생 시(예: 유닛 사망), Manager는 Event Channel을 통해 이벤트를 발행합니다.  
5. **시스템 간 통신:** 다른 Manager들이 이벤트를 수신하여 독립적으로 로직을 처리합니다. (예: ScoreManager가 OnUnitKilledEvent를 듣고 점수 추가)  
6. **UI 업데이트:** UI 컨트롤러가 이벤트를 수신하여 화면을 갱신할 준비를 합니다.  
7. **사용자 입력:** UI에서의 사용자 입력(예: 강화 버튼 클릭)은 다시 Event Channel을 통해 관련 Manager에 요청을 보냅니다.  
8. **데이터 바인딩:** ViewModel의 데이터가 변경되면, 데이터 바인딩을 통해 View(UXML)가 자동으로 업데이트됩니다.  
9. **로드:** 게임 시작 시, Manager들은 Save File을 로드하여 플레이어의 영구 데이터를 복원합니다.  
10. **저장:** 게임 종료 또는 특정 시점에, Manager들은 현재 상태를 Save File에 저장합니다.  
11. **밸런스 참조:** 모든 핵심 계산 로직은 Balance Data SO를 참조하여 유연한 밸런스 조정을 가능하게 합니다.  
12. **서버 요청:** 재화 사용, 강화 등 핵심 데이터 변경이 필요한 경우, 관련 Manager는 직접 로직을 처리하지 않고 ServerAPIManager에 요청을 보냅니다.  
13. **API 호출:** ServerAPIManager는 요청을 실제 서버 API 호출로 변환하여 전송합니다.  
14. **서버 검증:** 서버는 요청의 유효성을 검증하고(예: 재화 소모량 직접 계산), 결과를 클라이언트에 반환합니다. ServerAPIManager는 이 결과를 받아 관련 시스템에 전파합니다.

## **IV. 개발 로드맵 (Phase별)**

### **Phase 0: 핵심 기반 시스템 구축 (The Core Foundation)**

**목표:** 게임의 모든 다른 시스템이 의존하게 될 가장 근본적인 아키텍처와 데이터 구조를 완성합니다. 이 단계의 안정성이 프로젝트 전체의 안정성을 결정합니다.

| 단계 | 항목 | 상태 | 비고 |
| :---- | :---- | :---- | :---- |
| 0-1 | 프로젝트 초기 설정 및 폴더 구조 생성 | ⏳ To Do |  |
| 0-2 | SO 기반 이벤트 채널 시스템 구현 | ⏳ To Do |  |
| 0-3 | 통합 스탯 시스템 구현 | ⏳ To Do |  |
| 0-4 | 핵심 데이터 SO 청사진(Blueprint) 정의 | ⏳ To Do |  |
| 0-5 | 핵심 변수 경량 암호화/난독화 구현 | ⏳ To Do | 보안 강화 |
| 0-6 | 핵심 밸런스 데이터 구조 설계 및 SO 생성 | ⏳ To Do | **Phase 1의 전제 조건** |
| 0-7 | 시스템 통합 검증 및 문서화 | ⏳ To Do | Phase 0 완료 기준 |

#### **\[0-1\] 프로젝트 초기 설정 및 폴더 구조 생성**

* **의존성 및 산출물:**  
  * **신규 생성:** 전체 폴더 구조, .gitignore 파일, Git 저장소  
* **상세 구현:**  
  1. '던전 마스터\_ 폴더 구조 및 규칙 가이드 v1.9'에 명시된 모든 폴더 구조를 Unity 프로젝트 내에 미리 생성합니다.  
  2. Git 저장소를 초기화하고, Unity 표준 .gitignore 파일을 설정하여 Library, Temp, Logs 등 불필요한 파일 및 폴더가 버전 관리에서 제외되도록 합니다.  
  3. 팀의 코딩 스타일 가이드(네이밍 컨벤션, 괄호 위치 등)를 문서화하고 공유합니다.  
* **테스트 체크리스트:**  
  * \[ \] 모든 팀원이 동일한 Unity 버전(예: 2022.3.x LTS)과 필수 패키지(Input System, UI Toolkit, Addressables 등)를 설치했는지 확인합니다.  
  * \[ \] \_Project 폴더가 Unity 에디터의 Project 뷰에서 항상 최상단에 정렬되는지 확인합니다.  
  * \[ \] Git에 첫 커밋을 하고, 원격 저장소에 푸시하여 모든 팀원이 프로젝트를 클론할 수 있는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Pending Question:** CI/CD 파이프라인(예: GameCI) 도입 시점과 구체적인 빌드/테스트 자동화 정책을 초기에 확정해야 합니다.  
  * **Risk:** 팀원 간 Unity 버전 불일치 시, 라이브러리 충돌 및 예기치 않은 에디터 오류가 발생할 수 있습니다.

#### **\[0-2\] SO 기반 이벤트 채널 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** EventChannelSO.cs, VoidEventChannelSO.cs 등 이벤트 채널 스크립트, 기본 이벤트 채널 SO 애셋  
* **상세 구현:**  
  1. 'UI 아키텍처 설계 문서' 3.1절에 명시된 제네릭 기반 이벤트 채널(EventChannelSO\<T\>)을 구현합니다.  
  2. \#if UNITY\_EDITOR 전처리기 지시문을 사용하여 에디터에서만 동작하는 디버깅 기능(리스너가 없는 이벤트를 호출할 경우 경고 로그 출력)을 포함시킵니다.  
  3. 자주 사용될 기본 타입(Void, int, float, string)과 핵심 데이터 타입(UnitData, ArtifactData 등)에 대한 구체적인 SO 클래스를 미리 생성해둡니다.  
* **테스트 체크리스트:**  
  * \[ \] Assets \> Create \> Game/Events/ 메뉴를 통해 각 타입별 이벤트 채널 SO 애셋을 생성할 수 있는지 확인합니다.  
  * \[ \] NUnit을 사용하여 이벤트 발행(Raise) 및 구독(Subscribe/Unsubscribe) 기능이 정상 동작하는지 단위 테스트를 작성합니다.  
  * \[ \] 리스너가 없는 상태에서 이벤트를 발행했을 때 콘솔에 경고 로그가 정상적으로 출력되는지 테스트합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 이벤트 페이로드(Payload)로 큰 데이터를 자주 전달할 경우 성능에 영향을 줄 수 있습니다. 필요시 데이터 전체 대신 ID나 참조를 전달하는 방식을 고려해야 합니다.

#### **\[0-3\] 통합 스탯 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** CharacterStat.cs, StatModifier.cs, ModifierType.cs, IStatModifierSource.cs  
* **상세 구현:**  
  1. '기술 아키텍처 제안서'의 스탯 수정자 패턴을 기반으로 구현합니다.  
  2. CharacterStat.Value 프로퍼티는 get 접근 시점에 모든 \_statModifiers 리스트를 순회하며 최종 값을 계산하여 반환합니다.  
  3. **계산 순서:** (BaseValue \+ 모든 Flat 합계) \* (1 \+ 모든 PercentAdd 합계) \* (1 \+ PercentMult1) \* (1 \+ PercentMult2) ... 순서를 엄격히 준수해야 합니다.  
  4. 이 시스템은 \*\*순수 C\#\*\*으로 작성하여 UnityEngine에 대한 의존성을 완전히 제거합니다.  
  5. **정책 확정:** '피해감소율'은 CharacterStat으로 관리합니다. '보호율'과 '공격속도'는 아머 타입에 따라 결정되므로, ArmorTypeData에서 StatModifier를 제공하여 각 유닛의 관련 CharacterStat에 적용하는 방식으로 구현합니다.  
* **테스트 체크리스트:**  
  * \[ \] NUnit을 사용하여 CharacterStat 클래스에 대한 단위 테스트를 작성합니다.  
  * \[ \] 다양한 수정자(양수, 음수, 0, Flat, PercentAdd, PercentMult) 조합에 대한 계산 결과가 정확한지 검증하는 테스트 케이스를 작성합니다.  
  * \[ \] AddModifier, RemoveModifier, RemoveAllModifiersFromSource 기능이 정확하게 동작하는지 테스트합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 계산 순서가 잘못 구현될 경우, 게임 전체의 밸런스가 무너질 수 있습니다. 단위 테스트를 통해 계산 로직의 정확성을 철저히 검증해야 합니다.

#### **\[0-4\] 핵심 데이터 SO 청사진(Blueprint) 정의**

* **의존성 및 산출물:**  
  * **신규 생성:** UnitData.cs, EquipmentData.cs, SkillData.cs, DungeonRoomData.cs, ArtifactData.cs, EnemyFactionData.cs, ArmorTypeData.cs, AttributeCompatibilityData.cs  
* **상세 구현:**  
  1. 각 데이터는 ScriptableObject를 상속받는 클래스로 정의합니다.  
  2. \[CreateAssetMenu\] 어트리뷰트를 사용하여 기획자가 에디터에서 쉽게 데이터 애셋을 생성할 수 있도록 합니다.  
  3. 모든 수치 데이터(HP, 공격력 등)는 하드코딩 금지 규칙과 결정적 연산 규칙에 따라 int 또는 long 타입의 스케일된 정수형(예: hp\_x1000)으로 선언합니다.  
  4. 데이터 클래스 내에는 로직이 포함되어서는 안 되며, 순수한 데이터 컨테이너 역할만 수행합니다.  
* **테스트 체크리스트:**  
  * \[ \] 각 데이터 타입별로 테스트용 SO 애셋을 1\~2개 생성해보고, 인스펙터에 모든 필드가 정상적으로 노출되는지 확인합니다.  
  * \[ \] 네이밍 컨벤션에 따라 SO\_UnitData\_Goblin, SO\_ArmorData\_Heavy 와 같은 이름으로 애셋을 생성합니다.  
  * \[ \] AttributeCompatibilityData SO에 기획서의 상성표를 입력하고, 런타임에 조회 가능한 구조인지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Pending Question:** 게임 출시 후 라이브 밸런싱을 위해 이 SO들을 어떻게 관리하고 업데이트할지 정책을 수립해야 합니다. (Addressables \+ 원격 번들 방식 권장)

#### **\[0-5\] 핵심 변수 경량 암호화/난독화 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** ObfuscatedInt.cs, ObfuscatedFloat.cs 등 래퍼(Wrapper) 클래스  
* **상세 구현:**  
  1. int, float 등 주요 원시 타입을 래핑하는 구조체 또는 클래스를 작성합니다.  
  2. 내부적으로 실제 값은 고정된 Key 값과 XOR 연산 등을 통해 암호화된 상태로 저장합니다.  
  3. get 접근자는 암호화된 값을 복호화하여 반환하고, set 접근자는 입력된 값을 암호화하여 저장합니다.  
  4. **적용 대상:** PlayerData.cs 내의 재화(주화, 크리스탈), InGameUnit.cs 내의 현재 체력 등 메모리 변조에 취약한 핵심 변수.  
* **테스트 체크리스트:**  
  * \[ \] NUnit을 사용하여 암호화/복호화가 정확히 이루어지는지 테스트합니다.  
  * \[ \] 에디터 상에서 암호화된 변수의 값이 알아보기 힘든 형태로 표시되는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 암호화/복호화 연산은 미미한 성능 오버헤드를 유발합니다. Update() 문처럼 매 프레임 극도로 빈번하게 접근되는 변수에 적용할 경우 신중한 성능 테스트가 필요합니다.

#### **\[0-6\] 핵심 밸런스 데이터 구조 설계 및 SO 생성**

* **의존성 및 산출물:**  
  * **신규 생성:** ArmorTypeData.cs, AttributeCompatibilityData.cs 등 밸런스 SO 스크립트 및 애셋  
* **상세 구현:**  
  1. 기획서 6.1 항목에 따라, 전투 공식에 사용될 핵심 변수들의 데이터 구조를 SO로 정의합니다.  
  2. **아머 타입별 데이터:** ArmorTypeData SO를 생성하여, 각 아머 타입(경갑, 중갑 등)에 따른 보호율, 공격속도 수정치 등을 관리합니다.  
  3. **속성 상성 데이터:** AttributeCompatibilityData SO를 생성하여, 속성 간 상성 관계와 피해 배율을 2차원 배열 또는 리스트 형태로 관리합니다.  
  4. 이 단계에서 생성된 SO들은 기획자가 초기 밸런스 값을 입력할 수 있는 형태로 제공되어야 합니다.  
* **테스트 체크리스트:**  
  * \[ \] ArmorTypeData SO에 기획서의 값을 입력하고, 런타임에서 특정 아머 타입의 데이터를 정상적으로 조회할 수 있는지 테스트합니다.  
  * \[ \] AttributeCompatibilityData SO에 상성표를 입력하고, (물, 불) \-\> 0.5f 와 같이 특정 상성 관계의 배율을 정확히 조회하는 함수를 테스트합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 초기 데이터 구조 설계가 잘못될 경우, 이후 모든 밸런스 작업에 영향을 미칩니다. 기획자와 긴밀히 협력하여 확장 가능한 구조를 설계해야 합니다.

#### **\[0-7\] 시스템 통합 검증 및 문서화**

* **의존성 및 산출물:**  
  * **갱신:** 스크립트연결참조.txt  
* **상세 구현:**  
  1. **아키텍처 검증:** Phase 0에서 구현된 핵심 시스템(이벤트 채널, 스탯 시스템, 데이터 SO)들이 서로 의도대로 데이터를 주고받는지 간단한 통합 테스트 씬에서 검증합니다.  
  2. **문서화:** Phase 0에서 생성된 모든 핵심 스크립트, SO, 이벤트 채널의 역할과 연결 관계를 스크립트연결참조.txt에 기록합니다.  
  3. **성능 기준선 설정:** 빈 씬과 기본 UI만 있는 씬을 기준으로 타겟 모바일 기기에서의 FPS, 메모리 사용량, 빌드 크기 등 초기 성능 기준선을 측정하고 기록합니다.  
* **테스트 체크리스트:**  
  * \[ \] 이벤트 발행 \-\> 스탯 수정 \-\> 데이터 참조로 이어지는 간단한 시나리오가 정상 동작하는지 통합 테스트를 수행합니다.  
  * \[ \] 스크립트연결참조.txt에 Phase 0의 산출물이 모두 기록되었는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 이 단계에서 아키텍처의 근본적인 결함이 발견될 경우, 수정 비용이 크므로 철저한 검증이 필요합니다.

### **Phase 1: 핵심 게임 루프 완성 (MVP)**

**목표:** \[전투 → 보상 → 강화 → 재도전\]의 최소 기능 사이클을 완성하여, 게임의 가장 기본적인 재미를 테스트할 수 있는 빌드를 만듭니다.

| 단계 | 항목 | 상태 | 비고 |
| :---- | :---- | :---- | :---- |
| 1-1 | 유닛 생성 및 관리 시스템 | ⏳ To Do | Phase 0 완료 후 진행 |
| 1-2 | 기본 전투 시스템 구현 | ⏳ To Do | 1-1 완료 후 진행 |
| 1-3 | 로비 '베이스 카드 강화' UI 구현 | ⏳ To Do | 1-2 완료 후 진행 |
| 1-4 | 기본 UI 아키텍처 구현 | ⏳ To Do | 1-3과 병행 |
| 1-5 | 시스템 통합 검증 및 문서화 | ⏳ To Do | Phase 1 완료 기준 |

#### **\[1-1\] 유닛 생성 및 관리 시스템**

* **의존성 및 산출물:**  
  * **신규 생성 에셋:** PF\_InGameUnit.prefab, InGameUnit.cs, UnitManager.cs  
  * **참조 에셋:** UnitData.cs, ArmorTypeData.cs, CharacterStat.cs  
* **상세 구현:**  
  1. InGameUnit.cs MonoBehaviour 스크립트를 작성합니다. 이 스크립트는 CharacterStat 인스턴스들을 소유하고, Initialize 및 TakeDamage 메서드를 가집니다.  
  2. UnitManager.cs를 작성하여 UnitData SO를 기반으로 PF\_InGameUnit 프리팹을 인스턴스화하고 초기화하는 로직을 구현합니다.  
  3. **성능 가이드라인:** 한 웨이브에 50개 이상의 유닛이 동시에 스폰될 가능성이 있으므로, 초기부터 오브젝트 풀링 패턴 도입을 강력히 권장합니다. UnitManager는 PoolManager를 통해 유닛을 재활용하는 구조로 설계합니다.  
* **테스트 체크리스트:**  
  * \[ \] PF\_InGameUnit 프리팹을 생성하고 InGameUnit.cs를 연결합니다.  
  * \[ \] **테스트 씬 구성:** Assets/\_Project/Tests/Scenes/Features/Units/UnitSpawningTestScene.unity 씬을 생성합니다.  
  * \[ \] 해당 씬에서 UnitManager를 통해 특정 UnitData SO를 기반으로 유닛이 정상적으로 스폰/재활용되는지 테스트합니다.  
  * \[ \] 스폰된 유닛의 초기 스탯이 정확히 계산되었는지 디버거로 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** Initialize 로직이 복잡해질 경우, 유닛 생성 시 성능 저하가 발생할 수 있습니다. 오브젝트 풀링(Object Pooling) 도입을 초기부터 고려해야 합니다.

#### **\[1-2\] 기본 전투 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** CombatCalculator.cs, CombatLogManager.cs, CombatLog.cs (데이터 구조)  
  * **신규 이벤트:** SO\_Event\_OnUnitDamaged, SO\_Event\_OnUnitKilled  
* **상세 구현:**  
  1. CombatCalculator.cs를 구현하여 기획서 4.3.1의 데미지 공식을 코드로 변환합니다.  
  2. ProcessAttack 메서드는 attacker와 target의 CharacterStat, ArmorTypeData, AttributeCompatibilityData를 종합하여 최종 피해량을 계산합니다.  
  3. 계산된 피해량으로 target.TakeDamage()를 호출하고, SO\_Event\_OnUnitDamaged 이벤트를 발행합니다.  
  4. target의 체력이 0 이하가 되면 SO\_Event\_OnUnitKilled 이벤트를 발행합니다.  
  5. **핵심 전투 로그 수집:** CombatLogManager를 구현합니다. 이 매니저는 OnWaveStartEvent, OnSkillUsedEvent, OnUnitKilledEvent 등 핵심 전투 이벤트를 구독합니다.  
  6. 이벤트 발생 시, CombatLog 데이터 구조에 타임스탬프와 핵심 정보(예: 사용 스킬 ID, 사망 유닛 ID)를 기록합니다.  
  7. 전투 종료 시, 수집된 CombatLog는 서버 전송을 위해 ServerAPIManager에 전달됩니다. (초기에는 콘솔 출력)  
* **테스트 체크리스트:**  
  * \[ \] NUnit을 사용하여 CombatCalculator의 데미지 계산 로직을 테스트합니다.  
  * \[ \] **테스트 씬:** Assets/\_Project/Tests/Scenes/Features/Combat/CombatTestScene.unity에서 두 유닛의 전투를 시뮬레이션합니다.  
  * \[ \] 전투 시나리오 진행 시, 전투 시작, 스킬 사용, 유닛 사망 등의 로그가 CombatLogManager에 순서대로 정확히 기록되는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Pending Question:** 치명타, 스킬 계수 등 아직 정의되지 않은 변수들을 공식에 어떻게 포함시킬지 구체적인 계획이 필요합니다. 초기에는 해당 변수들을 1로 가정하고 구현합니다.

#### **\[1-3\] 로비 '베이스 카드 강화' UI 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** UpgradeCardViewModel.cs, UpgradeCardViewController.cs, ServerAPIManager.cs (Mock 포함)  
  * **신규 이벤트:** SO\_Event\_OnUpgradeCardRequested  
* **상세 구현:**  
  * **MVVM 패턴 및 서버 검증 아키텍처 적용:**  
    1. **View(UI):** 사용자가 '강화' 버튼을 클릭합니다.  
    2. **ViewModel:** UpgradeCommand를 실행하고, SO\_Event\_OnUpgradeCardRequested 이벤트를 발행합니다. ViewModel은 재화 계산 로직을 갖지 않습니다.  
    3. **PlayerDataManager(가칭):** 이벤트를 수신하고, 강화 요청에 필요한 정보(예: UnitData ID, 현재 강화 레벨)를 ServerAPIManager.RequestUpgradeCard() 메서드에 전달합니다.  
    4. **ServerAPIManager:** RequestUpgradeCard 메서드는 **(초기 단계에서는 Mock 로직으로)** 강화 비용을 직접 계산하고, 플레이어의 재화가 충분한지 검증한 후, 성공/실패 결과를 반환합니다.  
    5. PlayerDataManager는 결과를 받아 영구 데이터를 갱신하고, SO\_Event\_OnCardDataUpdated와 SO\_Event\_OnCurrencyChanged 이벤트를 발행하여 UI를 포함한 다른 시스템에 변경 사항을 알립니다.  
* **테스트 체크리스트:**  
  * \[ \] UpgradeCardView.uxml 파일과 UpgradeCardView.uss 파일을 생성합니다.  
  * \[ \] **테스트 씬:** Assets/\_Project/Tests/Scenes/Features/UI/UITestScene\_Lobby.unity에 UI를 배치합니다.  
  * \[ \] **Mock 데이터 활용:** MockUpgradeCardViewModel을 만들어 PlayerDataManager 없이 UI를 테스트합니다.  
  * \[ \] 강화 버튼 클릭 시, ViewModel이 아닌 ServerAPIManager의 Mock 로직을 통해 재화가 부족할 경우 요청이 거부되는지 테스트합니다.  
  * \[ \] 성공 시 PlayerDataManager를 통해 데이터가 갱신되고 UI가 올바르게 반영되는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Pending Question:** 강화 연출(VFX, SFX)의 구체적인 기획이 필요합니다. 연출 재생 시점을 위해 OnUpgradeSuccessEvent, OnUpgradeFailEvent 등 추가 이벤트 채널이 필요할 수 있습니다.

#### **\[1-4\] 기본 UI 아키텍처 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** UIManager.cs, UIPanel.cs (기본 클래스), 기본 UI 이벤트 채널 SO 애셋  
* **상세 구현:**  
  1. 'UI 아키텍처 설계 문서' 3.2절에 따라 UI 패널의 생명주기를 관리하는 UIManager를 구현합니다.  
  2. 모든 UI 패널이 상속받을 UIPanel 추상 클래스를 정의합니다. (Show, Hide 등 기본 메서드 포함)  
  3. UI 화면 전환을 위한 기본 이벤트 채널(예: SO\_Event\_ShowUIPanel)을 생성하고, UIManager가 이를 구독하여 동작하도록 구현합니다.  
  4. Phase 1-3의 '강화 화면'을 이 아키텍처에 맞게 통합합니다.  
* **테스트 체크리스트:**  
  * \[ \] 이벤트 채널을 통해 특정 UI 패널(강화 화면)을 열고 닫는 기능이 정상 동작하는지 테스트합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** UIManager가 너무 많은 역할을 갖지 않도록, 패널의 생명주기 관리에만 집중하도록 설계해야 합니다.

#### **\[1-5\] 시스템 통합 검증 및 문서화**

* **의존성 및 산출물:**  
  * **갱신:** 스크립트연결참조.txt  
  * **신규 생성:** 기획자용 SO 콘텐츠 제작 가이드 문서  
* **상세 구현:**  
  1. **핵심 루프 검증:** \[전투 → 보상(Mock) → 강화 → 재도전\]으로 이어지는 전체 게임 루프가 끊김 없이 동작하는지 통합 테스트를 수행합니다.  
  2. **문서화:** Phase 1에서 생성/수정된 모든 스크립트, SO, 이벤트, 프리팹의 연결 관계를 스크립트연결참조.txt에 업데이트합니다.  
  3. **성능 검증:** MVP 빌드의 성능을 Phase 0에서 설정한 기준선과 비교하여 심각한 성능 저하가 없는지 프로파일링을 통해 확인합니다.  
  4. **협업 워크플로우 구축:** 기획자가 프로그래머의 도움 없이 새로운 '베이스 카드(UnitData)' SO를 생성하고, 밸런스 값을 수정하여 게임에 즉시 적용할 수 있는지 검증하고, 그 과정을 담은 가이드 문서를 제작합니다.  
* **테스트 체크리스트:**  
  * \[ \] 통합 테스트 씬에서 핵심 게임 루프 시나리오가 성공적으로 완료되는지 확인합니다.  
  * \[ \] 스크립트연결참조.txt가 최신 상태인지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 이 단계에서 핵심 루프의 재미 요소가 부족하다고 판단될 경우, 기획의 근본적인 재검토가 필요할 수 있습니다.

### **Phase 2: 전략적 깊이 추가**

**목표:** MVP 루프 위에 핵심 전략 시스템들을 구현하여 로그라이크의 재미와 리플레이 가치를 더합니다.

| 단계 | 항목 | 상태 | 비고 |
| :---- | :---- | :---- | :---- |
| 2-1 | 위협도 시스템 구현 | ⏳ To Do | Phase 1 완료 후 진행 |
| 2-2 | 유물 시스템 구현 | ⏳ To Do | 2-1 완료 후 진행 |
| 2-3 | 적 세력 시스템 구현 | ⏳ To Do | 2-2 완료 후 진행 |
| 2-4 | 마신전 시스템 구현 | ⏳ To Do | 2-3 완료 후 진행 |
| 2-5 | 서버 연동 및 검증 로직 구현 | ⏳ To Do | 보안 강화 |
| 2-6 | 시스템 통합 검증 및 문서화 | ⏳ To Do | Phase 2 완료 기준 |

#### **\[2-1\] 위협도 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** ThreatManager.cs, ThreatLevelSO.cs  
  * **신규 이벤트:** SO\_Event\_OnThreatLevelChanged  
* **상세 구현:**  
  1. ThreatLevelSO는 현재 위협도 값을 저장하는 전역 변수 역할을 하는 ScriptableObject입니다.  
  2. ThreatManager는 위협도 변경 로직을 담당합니다. '침략 성공'과 같은 이벤트를 수신하면 \_currentThreatLevel SO의 값을 변경하고, OnThreatLevelChangedEvent를 발행합니다.  
  3. UnitManager(또는 EnemySpawner)는 OnThreatLevelChangedEvent를 구독하거나, 적 생성 시점에 \_currentThreatLevel SO 값을 직접 참조하여 적 스탯에 보너스 StatModifier를 적용합니다. (예: 위협도 1당 공격력/체력 \+0.5% PercentAdd 수정자 추가)  
* **테스트 체크리스트:**  
  * \[ \] SO\_Global\_ThreatLevel 애셋을 생성하고 초기값을 0으로 설정합니다.  
  * \[ \] 테스트용 '위협도 증가' 버튼을 만들어 클릭 시 ThreatManager를 통해 위협도 SO 값이 변경되고, OnThreatLevelChangedEvent가 발행되는지 확인합니다.  
  * \[ \] 위협도가 증가한 상태에서 적을 스폰했을 때, 해당 적의 스탯이 정상적으로 강화되었는지 디버거로 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 위협도 증가에 따른 적 강화 공식이 밸런스에 큰 영향을 미치므로, 이 공식 자체를 BalanceData SO로 분리하여 관리하는 것을 고려해야 합니다.

#### **\[2-2\] 유물 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** ArtifactManager.cs  
  * **참조 에셋:** ArtifactData.cs  
  * **신규 이벤트:** SO\_Event\_OnArtifactAcquired  
* **상세 구현:**  
  1. ArtifactManager는 인스턴스 내에서만 활성화되는 싱글톤 또는 서비스 로케이터 패턴으로 관리됩니다.  
  2. OnArtifactAcquiredEvent 이벤트가 발생하면, 해당 ArtifactData를 \_ownedArtifacts 리스트에 추가합니다.  
  3. 유물 효과 적용:  
     * **즉시 발동 효과** (예: 재화 획득): ArtifactManager가 이벤트를 수신하는 즉시 관련 시스템(예: CurrencyManager)에 이벤트를 발행하여 처리합니다.  
     * **지속 효과** (예: 특정 속성 유닛 스탯 증가): ArtifactManager는 유물 획득 시, 현재 씬에 존재하는 모든 유닛을 순회하며 조건(예: unit.UnitBlueprint.attributeType \== AttributeType.Fire)에 맞는 유닛에게 StatModifier를 추가합니다.  
  4. OnUnitSpawnedEvent를 구독하여, 새로 생성되는 유닛에게도 기존에 획득한 모든 유물의 지속 효과가 적용되도록 보장합니다.  
* **테스트 체크리스트:**  
  * \[ \] 다양한 효과(스탯 수정, 특수 능력 부여 등)를 가진 테스트용 ArtifactData SO 애셋을 생성합니다.  
  * \[ \] 테스트용 '유물 획득' 버튼을 만들어 OnArtifactAcquiredEvent를 발행하고, ArtifactManager가 이를 정상적으로 수신하는지 확인합니다.  
  * \[ \] 유물 획득 후, 조건에 맞는 유닛들의 스탯이 StatModifier에 의해 정확히 변경되었는지 디버거로 확인합니다.  
  * \[ \] 유물 획득 후 새로 스폰된 유닛에게도 동일한 효과가 적용되는지 테스트합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 유물 효과가 중첩될 때 예기치 않은 밸런스 붕괴가 일어날 수 있습니다. 특정 유물은 중복 획득을 막거나, 효과에 상한선을 두는 등의 정책이 필요할 수 있습니다.

#### **\[2-3\] 적 세력 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** EnemyWaveManager.cs  
  * **참조 에셋:** EnemyFactionData.cs  
  * **신규 이벤트:** SO\_Event\_OnWaveStart  
* **상세 구현:**  
  1. 웨이브 시작 시, EnemyWaveManager는 EnemyFactionData SO 목록에서 이번 웨이브에 등장할 세력을 하나 선택합니다.  
  2. 선택된 세력 정보를 담아 OnWaveStartEvent를 발행하여, UI 시스템 등이 "이번 웨이브는 \[성기사단\]입니다\!" 와 같은 정보를 표시할 수 있도록 합니다.  
  3. UnitManager는 적 유닛을 스폰할 때, \_currentWaveFaction 데이터를 참조합니다.  
  4. 스폰되는 적이 해당 세력 소속일 경우, EnemyFactionData에 정의된 공통 StatModifier들을 해당 유닛의 CharacterStat에 추가하여 세력 전체 강화 효과를 구현합니다.  
* **테스트 체크리스트:**  
  * \[ \] 기획서 예시에 따라 '성기사단', '숲의 엘프' 등 테스트용 EnemyFactionData SO를 생성하고, 각각 다른 스탯 수정자를 설정합니다.  
  * \[ \] 웨이브 시작 시 OnWaveStartEvent가 올바른 세력 데이터와 함께 발행되는지 확인합니다.  
  * \[ \] 특정 세력 웨이브에서 스폰된 적들이 해당 세력의 고유한 스탯 보너스를 받았는지 디버거로 확인합니다.  
* **리스크 및 고려사항:**  
  * **Pending Question:** 특정 세력에 대한 카운터 전략이 명확하도록 세력별 특징(예: 특정 속성 저항, 특정 타입에 추가 피해)을 더 구체화해야 합니다.

#### **\[2-4\] 마신전 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** HallOfGodsManager.cs, HallOfGodsNodeData.cs (SO), HallOfGodsTreeData.cs (SO)  
  * **신규 이벤트:** SO\_Event\_OnUnlockHallOfGodsNodeRequested  
* **상세 구현:**  
  1. HallOfGodsManager는 게임 전체 생명주기를 가지는 영구적인 관리자입니다. 게임 시작 시, 플레이어의 저장 데이터로부터 해금된 마신전 노드 목록(\_unlockedNodes)을 불러옵니다.  
  2. OnGameStartEvent(인게임 씬 시작 이벤트)를 수신하면, \_unlockedNodes에 포함된 모든 영구 StatModifier들을 현재 인스턴스에 적용합니다. (예: UnitManager에 전달하여 모든 유닛 생성 시 기본 적용하도록 함)  
  3. 마신전 트리 UI에서 플레이어가 특정 노드 해금을 시도하면, UI의 ViewModel은 OnUnlockHallOfGodsNodeRequestedEvent를 발행합니다.  
  4. HallOfGodsManager는 이 이벤트를 수신하여 '마신전 포인트'(가칭) 재화가 충분한지 확인하고, 조건 충족 시 해당 노드를 해금 처리(영구 데이터에 저장)한 뒤, OnHallOfGodsNodeUnlockedEvent를 발행하여 UI를 갱신합니다.  
* **테스트 체크리스트:**  
  * \[ \] HallOfGodsNodeData SO와 이를 계층 구조로 관리하는 HallOfGodsTreeData SO를 생성합니다. 각 노드에 테스트용 영구 스탯 수정자를 설정합니다.  
  * \[ \] 테스트 UI를 통해 특정 마신전 노드를 해금하고, 게임을 재시작해도 해금 상태가 유지되는지 확인합니다.  
  * \[ \] 마신전 노드 해금 후 인게임에 진입했을 때, 모든 아군 유닛에게 해당 노드의 영구 스탯 보너스가 적용되었는지 디버거로 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 마신전 트리 구조가 복잡해질 경우, 노드 간의 의존성 관리(선행 노드 해금 여부 체크 등) 로직이 필요하며, 이를 잘못 구현하면 데이터가 꼬일 수 있습니다.

#### **\[2-5\] 서버 연동 및 검증 로직 구현**

* **의존성 및 산출물:**  
  * **수정:** ServerAPIManager.cs  
* **상세 구현:**  
  1. Phase 1-3에서 Mock으로 구현했던 ServerAPIManager를 실제 간이 서버와 연동합니다.  
  2. '영구 성장 서버 직접 검증' 보안 계획에 따라, 강화/성장 요청 시 클라이언트는 ID만 보내고 서버가 비용 계산, 재화 차감, 결과 반환을 모두 처리하도록 API를 구현하고 연동합니다.  
* **테스트 체크리스트:**  
  * \[ \] 간이 서버 환경에서 강화 요청 시, 서버에서 재화가 정상적으로 차감되고 클라이언트에 결과가 반영되는지 테스트합니다.  
  * \[ \] 비정상적인 요청(예: 재화 부족) 시 서버가 요청을 거부하는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 네트워크 통신 실패 시 재시도 로직, 서버 점검 시 안내 등 예외 상황 처리가 반드시 필요합니다.

#### **\[2-6\] 시스템 통합 검증 및 문서화**

* **의존성 및 산출물:**  
  * **갱신:** 스크립트연결참조.txt  
* **상세 구현:**  
  1. **상호작용 검증:** 유물, 적 세력, 마신전 시스템이 서로에게 올바르게 영향을 주는지 복합적인 시나리오를 통해 검증합니다. (예: 특정 마신전 노드 해금 \+ 특정 유물 획득 시 스탯이 중첩 적용되는지)  
  2. **확장성 검증:** 새로운 UnitData, ArtifactData SO를 추가했을 때, 별도의 코드 수정 없이 게임에 정상적으로 적용되는지 테스트하여 아키텍처의 확장성을 검증합니다.  
  3. **문서화:** Phase 2의 산출물을 스크립트연결참조.txt에 업데이트합니다.  
  4. **성능 검증:** 복잡한 시스템이 추가된 상태에서 성능 프로파일링을 수행하고, 최적화가 필요한 부분을 식별합니다.  
* **테스트 체크리스트:**  
  * \[ \] 여러 전략 시스템이 동시에 활성화된 상태에서 게임 플레이가 의도대로 동작하는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 시스템 간 상호작용으로 인해 예측하지 못한 밸런스 붕괴나 버그가 발생할 가능성이 높으므로, 다양한 조합에 대한 충분한 테스트가 필요합니다.

### **Phase 3: 폴리싱 및 메타 기능 확장**

**목표:** 핵심 시스템을 기반으로 게임의 완성도를 높이고, 장기적인 플레이 동기를 부여하는 부가 시스템을 구현합니다.

| 단계 | 항목 | 상태 | 비고 |
| :---- | :---- | :---- | :---- |
| 3-1 | 도전 과제 시스템 구현 | ⏳ To Do | Phase 2 완료 후 진행 |
| 3-2 | UI/UX 폴리싱 | ⏳ To Do | 3-1 완료 후 진행 |
| 3-3 | 사운드 시스템 및 에셋 통합 | ⏳ To Do | 병렬 진행 가능 |
| 3-4 | 데이터 저장/로드 시스템 구현 | ⏳ To Do | 3-1 완료 후 진행 |

#### **\[3-1\] 도전 과제 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** AchievementManager.cs, AchievementData.cs  
  * **신규 이벤트:** SO\_Event\_OnAchievementCompleted  
* **상세 구현:**  
  1. AchievementManager는 영구적인 관리자입니다. 게임 시작 시 모든 AchievementData SO를 로드하고, 플레이어의 저장 데이터로부터 과제 진행 상황(\_progress)을 불러옵니다.  
  2. 로드된 각 AchievementData에 명시된 eventToListen을 동적으로 구독합니다.  
  3. 이벤트가 발생하면, 해당 이벤트와 연결된 과제들의 진행도를 갱신합니다. (예: OnUnitKilledEvent 발생 시, '누적 100킬' 과제의 진행도 \+1)  
  4. 진행도가 목표치(targetValue)에 도달하면, 과제를 완료 처리하고 OnAchievementCompletedEvent를 발행하여 보상 지급 및 UI 갱신을 트리거합니다.  
* **테스트 체크리스트:**  
  * \[ \] 다양한 조건과 보상을 가진 테스트용 AchievementData SO를 여러 개 생성합니다.  
  * \[ \] **테스트 자동화:** 특정 이벤트를 강제로 발행하는 에디터 메뉴를 만들어, 과제 진행 및 완료 로직을 코드 수정 없이 테스트할 수 있도록 합니다.  
  * \[ \] 과제 완료 시 보상('마신전 포인트' 등)이 정상적으로 지급되는지 테스트합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 구독해야 할 이벤트가 매우 많아질 경우, AchievementManager의 초기 설정이 복잡해지고 성능에 미미한 영향을 줄 수 있습니다. 이벤트 구독/해제 로직을 철저히 관리해야 합니다.

#### **\[3-2\] UI/UX 폴리싱**

* **의존성 및 산출물:**  
  * **신규 생성:** CombatLogUIController.cs, UnitTooltipController.cs  
* **상세 구현:**  
  1. **전투 로그:** CombatLogUIController는 OnUnitDamagedEvent와 같은 전투 관련 이벤트를 구독합니다. 이벤트 수신 시, "A가 B에게 100의 피해를 입혔습니다."와 같은 로그 메시지를 생성하여 UI의 ListView에 추가합니다. ListView를 사용하여 UI 가상화를 구현하고 성능을 최적화합니다.  
  2. **상세 정보 툴팁:** 유닛의 UI 요소에 UnitTooltipController 로직을 연결합니다. 마우스/터치 포인터가 유닛 위에 올라가면(OnPointerEnterEvent), 해당 유닛의 CharacterStat 정보를 상세히 조회하여 툴팁 UI에 표시합니다. 이때, (최종값) \= (기본값) \+ (장비) \+ (버프) 와 같이 스탯이 어떻게 구성되었는지 세부 내역을 보여주어 전략적 깊이를 시각화합니다.  
* **테스트 체크리스트:**  
  * \[ \] 전투 중 발생하는 모든 피해와 효과가 전투 로그에 실시간으로 정확히 기록되는지 확인합니다.  
  * \[ \] 유닛 위에 마우스를 올렸을 때, 모든 스탯의 상세 정보(기본값, 수정자 내역)가 정확하게 표시되는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 전투 로그가 너무 많이 쌓일 경우 UI 성능이 저하될 수 있습니다. 로그의 최대 개수를 제한하고, 오래된 로그는 제거하는 로직이 필요합니다.

#### **\[3-3\] 사운드 시스템 및 에셋 통합**

* **의존성 및 산출물:**  
  * **신규 생성:** SoundManager.cs, AudioData.cs  
  * **신규 이벤트:** SO\_Event\_PlaySound  
* **상세 구현:**  
  1. SoundManager는 DontDestroyOnLoad로 관리되는 싱글톤입니다. BGM과 SFX를 위한 별도의 AudioSource를 가집니다.  
  2. 게임 내 모든 사운드 재생 요청은 SoundManager를 통해 이루어집니다. 각 시스템은 SoundManager를 직접 참조하는 대신, 사운드 재생이 필요한 시점에 PlaySoundEvent(Payload: AudioData)를 발행하는 것을 권장합니다.  
  3. SoundManager는 PlaySoundEvent를 구독하고 있다가, 요청된 사운드를 재생합니다.  
  4. AudioData SO를 사용하여 사운드 클립과 관련 설정을 묶어 관리하면, 기획자가 코드 수정 없이 사운드를 교체하거나 볼륨을 조절할 수 있습니다.  
* **테스트 체크리스트:**  
  * \[ \] BGM과 SFX가 각각의 오디오 믹서 그룹에 연결되어, 전체 볼륨 조절이 가능한지 확인합니다.  
  * \[ \] 씬 전환 시 BGM이 끊기지 않고 자연스럽게 이어지거나 페이드 인/아웃 되는지 테스트합니다.  
  * \[ \] 짧은 시간 내에 동일한 효과음이 여러 번 재생될 때 사운드가 겹치거나 깨지지 않는지 확인합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 오디오 에셋의 로드 타입(Streaming, Decompress on Load 등)을 잘못 설정할 경우 메모리 사용량이 급증할 수 있습니다. BGM은 Streaming, 짧은 SFX는 Decompress on Load로 설정하는 것을 원칙으로 합니다.

#### **\[3-4\] 데이터 저장/로드 시스템 구현**

* **의존성 및 산출물:**  
  * **신규 생성:** SaveLoadManager.cs, PlayerData.cs (Serializable class)  
* **상세 구현:**  
  1. SaveLoadManager는 영구 데이터(재화, 클리어 기록, 해금된 마신전 노드 등)를 관리하는 모든 매니저(예: CurrencyManager, HallOfGodsManager)로부터 저장할 데이터를 요청합니다.  
  2. 수집된 데이터는 PlayerData 클래스 인스턴스에 담겨, JsonUtility나 Newtonsoft.Json을 사용하여 JSON 형식으로 직렬화됩니다.  
  3. 직렬화된 데이터는 Application.persistentDataPath에 파일로 저장됩니다. 보안을 위해 간단한 암호화(XOR 등)를 적용하는 것을 고려합니다.  
  4. 게임 시작 시, SaveLoadManager는 저장된 파일을 로드하고 역직렬화하여 각 데이터 매니저에 전달, 게임 상태를 복원합니다.  
* **테스트 체크리스트:**  
  * \[ \] 게임을 진행한 후 종료했다가 다시 켰을 때, 재화와 강화 상태, 마신전 해금 상태 등이 정확하게 복원되는지 테스트합니다.  
  * \[ \] 저장 파일이 없을 때, 게임이 오류 없이 기본 상태로 시작되는지 확인합니다.  
  * \[ \] 앱이 비정상적으로 종료(강제 종료 등)되었을 때를 대비하여, 특정 시점(예: 전투 종료 후)에 자동 저장 기능이 동작하는지 테스트합니다.  
* **리스크 및 고려사항:**  
  * **Risk:** 향후 업데이트로 PlayerData의 구조가 변경될 경우, 이전 버전의 저장 파일과 호환성 문제가 발생할 수 있습니다. 데이터 버저닝(Versioning) 시스템을 도입하여 구버전 데이터를 신버전 구조로 변환하는 마이그레이션 로직을 준비해야 합니다.

## **V. 보안 및 안티치트 구현 계획**

본 프로젝트는 아래의 다계층 보안 전략을 채택하여 부정 행위를 방지합니다.

| 계층 | 전략 | 대응 치트 | 관련 구현 계획 |
| :---- | :---- | :---- | :---- |
| **클라이언트** | **Google Play Integrity API** \+ **변수 암호화/난독화** | 루팅/위변조 앱 실행, 메모리 변조 | Phase 0-5, Phase 3 이후 |
| **통신** | **핵심 액션 로그 전송** | 전투 관련 행위 검증 데이터 확보 | Phase 1-2 |
| **서버** | **최종 판정 및 서버 직접 계산** | SO 데이터 변조, 재화핵, 성장핵, 전투핵 | Phase 1-3, Phase 3 이후 |

#### **1\. 권장 구현 로드맵 (우선순위)**

1. **영구 성장 서버 직접 검증 (보강 2):** 재화 및 성장 관련 핵을 원천적으로 방지하는 가장 핵심적인 방어선입니다. Phase 1의 강화 시스템 구현 시 즉시 적용합니다.  
2. **핵심 변수 경량 암호화/난독화 (보강 3):** 구현 난이도가 낮고 즉각적인 효과를 볼 수 있습니다. Phase 0의 기반 시스템 구축 시 적용하여 초기부터 메모리 변조 시도를 어렵게 만듭니다.  
3. **핵심 전투 로그 \+ 약식 시뮬레이터 (보강 1):** 전투 시스템 구현과 병행하여 로그 수집 기능을 내장하고, 서버 측 검증 로직은 추후 간이 서버 오픈 시점에 구현합니다.

## **VI. 디버깅 및 품질 관리 전략**

#### **1\. 테스트 전략 및 자동화**

* **단위 테스트 (Unit Test):**  
  * **대상:** 순수 C\# 로직 (스탯 시스템, 데미지 계산, ViewModel 로직 등).  
  * **도구:** Unity Test Framework (Edit Mode).  
  * **정책:** 모든 핵심 로직은 반드시 단위 테스트 코드를 동반해야 하며, CI/CD 파이프라인에서 자동으로 실행되어야 합니다.  
* **통합 테스트 (Integration Test):**  
  * **대상:** 여러 시스템이 연동되는 기능 (유닛 스폰 → 전투 → 보상 지급).  
  * **도구:** Unity Test Framework (Play Mode).  
  * **정책:** 주요 기능별로 테스트 씬을 구성하고, Play Mode 테스트를 작성하여 기능의 전체 흐름이 정상 동작하는지 검증합니다.  
* **Mock 데이터 및 씬 관리:**  
  * **폴더 구조:** Assets/\_Project/Tests/ 폴더 아래에 기능별로 테스트 씬과 Mock 데이터 SO를 관리합니다. (예: Assets/\_Project/Tests/Data/Units/SO\_UnitData\_MockGoblin.asset)  
  * **목표:** 각 기능이 다른 시스템에 대한 의존성 없이 독립적으로 테스트될 수 있도록 Mock 환경을 구축합니다.

#### **2\. 로깅 및 이벤트 추적**

* **중앙화된 로거:** Debug.Log를 직접 사용하는 대신, 로그 카테고리(예: Combat, UI, Data)와 로그 레벨( Debug, Info, Warning, Error)을 지원하는 커스텀 Logger 클래스를 구현합니다. 이를 통해 빌드 시 특정 카테고리나 레벨의 로그만 포함시키거나 제외할 수 있습니다.  
* **이벤트 히스토리:** 'UI 아키텍처 문서'의 DebugEventHistory 시스템을 개발 빌드에 포함하여, 에디터에서 이벤트 발생 순서와 내용을 실시간으로 추적합니다. 성능 부하가 우려될 경우, DebugEventHistory.IsRecording 플래그를 통해 기능을 비활성화할 수 있도록 합니다.  
* **화면 디버거:** 개발 빌드에서는 화면 한쪽에 간단한 디버그 정보를 표시하는 UI(FPS, 메모리 사용량, 현재 씬 이름 등)를 포함시키고, 콘솔 로그를 실시간으로 확인할 수 있는 기능을 구현합니다.

#### **3\. 예외 처리 정책**

* **사용자 경험 우선:** try-catch 구문을 사용하여 예상 가능한 오류(예: 파일 로드 실패, 네트워크 통신 실패)를 처리합니다. 오류 발생 시 게임이 중단되는 대신, "데이터를 불러오는 데 실패했습니다. 잠시 후 다시 시도해주세요."와 같은 친화적인 메시지를 UI 팝업으로 표시하고, 개발자를 위한 상세한 오류 정보는 Logger를 통해 기록합니다.  
* **Null 참조 방지:** Assert나 명시적인 null 체크를 통해 중요한 참조가 누락되었을 경우, 조기에 오류를 발생시켜 문제를 빠르게 인지하고 수정할 수 있도록 합니다.

#### **4\. 성능 최적화 (모바일 특화)**

* **에셋 최적화 체크리스트:** 모든 아트 및 사운드 에셋은 '에셋 통합 및 성능 최적화 상세 계획' 문서에 따라 아래 기준을 준수해야 합니다.  
  * \[ \] **스프라이트 아틀라스:** 모든 인게임/UI 스프라이트는 종류별(캐릭터, 배경, UI 등)로 **Sprite Atlas**에 그룹화하여 드로우 콜을 최소화합니다.  
  * \[ \] **텍스처 압축:** 타겟 플랫폼에 맞춰 **ASTC** 압축 포맷을 기본으로 사용합니다.  
  * \[ \] **PPU 및 필터 모드:** 모든 2D 도트 에셋은 프로젝트의 PPU(Pixels Per Unit) 값을 일관되게 사용하고, 텍스처 임포트 설정에서 \*\*Filter Mode를 Point (no filter)\*\*로 설정하여 흐려짐을 방지합니다.  
* **UI 최적화:**  
  * \[ \] **ListView 사용:** 인벤토리, 도감 등 많은 목록을 표시하는 UI는 반드시 ListView 컨트롤을 사용하여 UI 가상화를 구현합니다.  
  * \[ \] **애니메이션 최적화:** UI 애니메이션은 레이아웃 재계산을 유발하는 width, height 속성 대신, 성능에 최적화된 transform (translate, rotate, scale)과 opacity 속성을 우선적으로 사용합니다.

## **VII. 부록: 표준 및 체크리스트**

#### **A. PR (Pull Request) 리뷰 표준 체크리스트**

| 항목 | 체크 | 비고 |
| :---- | :---- | :---- |
| **1\. 빌드 성공** | \[ \] | PR 브랜치에서 클린 빌드가 성공하는가? |
| **2\. 테스트 통과** | \[ \] | 모든 단위/통합 테스트가 통과하는가? |
| **3\. 문서 준수** | \[ \] | 네이밍, 폴더 구조 등 관련 문서를 준수했는가? |
| **4\. 아키텍처 원칙** | \[ \] | 이벤트 채널 사용, SO 불변성 등 핵심 원칙을 위배하지 않았는가? |
| **5\. 가독성 및 주석** | \[ \] | 코드가 명확하며, 필요한 부분에 주석이 작성되었는가? |
| **6\. 성능 고려** | \[ \] | Update() 내 무거운 로직 등 잠재적인 성능 이슈는 없는가? |

#### **B. 기능 QA 표준 체크리스트**

| 항목 | 체크 | 비고 |
| :---- | :---- | :---- |
| **1\. 기획 의도 구현** | \[ \] | 기능이 기획서의 의도대로 정확히 동작하는가? |
| **2\. UI/UX 검증** | \[ \] | UI 깨짐, 오타, 불편한 조작 등은 없는가? |
| **3\. 예외 상황 처리** | \[ \] | 비정상적인 입력이나 상황에서 앱이 중단되거나 데이터가 꼬이지 않는가? |
| **4\. 데이터 검증** | \[ \] | 기능 사용 후 관련 데이터(재화, 스탯 등)가 정확히 저장/로드되는가? |
| **5\. 타 기능 영향** | \[ \] | 신규 기능이 기존 기능에 악영향을 주지 않는가? (회귀 테스트) |

#### **C. 밸런스 데이터 관리 가이드 (심화)**

* **권장 도구:** CSV 또는 Google Sheets를 사용하여 밸런스 데이터를 관리하고, Unity 에디터 내에서 버튼 클릭으로 해당 데이터를 ScriptableObject 애셋으로 변환하는 커스텀 툴 제작을 권장합니다.  
* **장점:** 프로그래머의 개입 없이 기획자가 빠르고 안전하게 밸런스를 수정하고 테스트할 수 있습니다.  
* **히스토리 관리:** Git을 통해 SO 애셋의 변경 이력을 관리하여, 언제 누가 어떤 수치를 변경했는지 추적하고 필요시 이전 버전으로 롤백할 수 있습니다.

#### **D. 비상 대응 가이드 (심화)**

* **저장 데이터 손상:** 데이터 구조 변경 시, 구버전 데이터를 신버전으로 변환하는 '마이그레이션' 코드를 반드시 작성합니다. 변환 실패 시, 데이터를 초기화하기 전에 서버에 백업하거나 사용자에게 안내 팝업을 띄우는 정책을 수립합니다.  
* **치명적 버그 발생:** 라이브 서비스 중 치명적인 버그 발견 시, 긴급 점검을 통해 서버에서 특정 기능을 비활성화할 수 있는 '피처 플래그(Feature Flag)' 시스템 도입을 장기적으로 고려합니다.

## **VIII. 향후 확장 계획**

본 문서는 핵심 싱글플레이 경험 구축에 집중합니다. 아래 항목들은 MVP 및 초기 버전 출시 이후, 별도의 상세 기획 및 개발 계획을 통해 진행될 수 있습니다.

#### **1\. 라이브 서비스 및 운영 도구**

안정적인 라이브 서비스를 위해 아래와 같은 운영 도구 구축을 장기적인 목표로 합니다.

| 도구 분류 | 주요 기능 예시 | 기대 효과 |
| :---- | :---- | :---- |
| **데이터/밸런스 관리 툴** | 웹 기반 대시보드에서 SO 데이터 실시간 조회 및 수정, A/B 테스트 그룹 관리 | 앱 업데이트 없는 신속한 밸런스 패치 및 데이터 기반 의사결정 |
| **유저 데이터 조회/관리** | 특정 유저의 재화, 아이템, 진행 상황 등 조회 및 수정, 아이템 지급 | 신속하고 정확한 고객 지원(CS), 계정 복구 |
| **통계 및 모니터링 대시보드** | DAU/MAU, 매출, 주요 재화 소모/획득량 등 핵심 지표(KPI) 시각화, 서버 부하 및 에러율 실시간 모니터링 | 데이터 기반의 게임 개선, 장애 발생 시 빠른 인지 및 대응 |
| **이벤트/공지 관리 시스템** | 인게임 이벤트 스케줄링, 푸시 알림 발송, 공지사항 및 배너 관리 | 유연하고 다채로운 라이브 이벤트 진행, 유저 재방문율 증대 |

#### **2\. 추가 확장 계획**

* **외부 서비스 연동:** 광고 SDK 연동, 소셜 미디어(로그인, 공유) 연동, 스토어 결제(IAP) 시스템  
* **비동기 PvP 콘텐츠:** 타 유저 던전 침공, 랭킹 시스템 등  
* **보안 강화:** 클라이언트 데이터 변조 방지(서버 검증, 메모리 암호화 등)  
* **콘텐츠 확장:** 신규 몬스터/마왕, 던전 테마, 스토리 모드 등